<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>并发编程中的一些基础知识</title>
    <link href="/2025/03/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/03/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><strong>进程和线程</strong></h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h2><p>进程是程序运行的基本单位。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，我们启动 <code>main</code> 函数时其实就是启动了一个 JVM 的线程，而 <code>main</code> 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h2><p>线程是比进程更小的程序执行单位，一个进程在其执行过程中可以产生多个线程。</p><p>同一个进程中的多个线程共享一个 <strong>堆</strong> 和 <strong>方法区</strong>，但每个线程有自己 <strong>独立</strong> 的 <strong>程序计数器(PC)、虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><h2 id="二者的区别和联系"><a href="#二者的区别和联系" class="headerlink" title="二者的区别和联系"></a><strong>二者的区别和联系</strong></h2><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于**各进程基本上是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。**线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p>线程之间的切换所产生的负担比进程之间的切换要小得多，原因如下：</p><ul><li><p><strong>共享资源</strong>：同一进程内的线程共享同一个地址空间、文件描述符和其他资源，不需要像进程切换那样重新加载内存映射和管理数据结构。</p></li><li><p><strong>上下文保存量少</strong>：线程切换只需要保存少量寄存器状态（例如程序计数器、栈指针等），而进程切换需要保存整个进程的上下文，并且往往还需要刷新TLB和切换虚拟内存环境。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="img"></p></li></ul><h1 id="Java-线程与操作系统线程的区别和联系"><a href="#Java-线程与操作系统线程的区别和联系" class="headerlink" title="Java 线程与操作系统线程的区别和联系"></a><strong>Java 线程与操作系统线程的区别和联系</strong></h1><h2 id="用户线程和内核线程"><a href="#用户线程和内核线程" class="headerlink" title="用户线程和内核线程"></a><strong>用户线程和内核线程</strong></h2><p>用户线程创建和切换成本低，但无法利用多核，运行在用户空间。</p><p>内核线程创建和切换成本高，但可以利用多核，运行在内核空间。</p><h2 id="Java-Thread"><a href="#Java-Thread" class="headerlink" title="Java Thread"></a><strong>Java Thread</strong></h2><p>JDK 1.2 以前，Java的多线程实质上是JVM模拟的多线程运行，并不依赖于操作系统。这种模拟的多线程使得模拟的多线程只能够在一个内核线程上运行。这是一种<strong>用户线程</strong>。</p><p>JDK 1.2 及以后，Java线程改为基于原生线程(Naive Thread)实现，也就是JVM直接调用操作系统的原生线程来实现Java线程，由操作系统内核进行线程的调度及管理。这是一种<strong>内核线程</strong>。</p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a><strong>线程的生命周期</strong></h2><p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png" alt="img"></p><p>当使用 new 关键字新建一个 Thread，这个 Thread 就进入了新建状态。</p><p>当调用这个 Thread 的 <code>start()</code> 方法时，系统就会启动另一个线程并使其进入就绪状态。</p><p>当分配到时间片后，这个 Thread 就会开始运行。系统会自动调用该线程 <code>Runnable</code> 接口的 <code>start()</code> 方法。</p><p>注意：如果我们直接调用 Thread 的 <code>run()</code> 方法，那么系统就会将其当成一个 main 线程下的普通方法去执行，并不会在某个其他的线程中执行，所以这并不是多线程工作。</p><h3 id="Object-wait-和-Thread-sleep-的区别"><a href="#Object-wait-和-Thread-sleep-的区别" class="headerlink" title="Object.wait() 和 Thread.sleep() 的区别"></a><code>Object.wait()</code> 和 <code>Thread.sleep()</code> 的区别</h3><table><thead><tr><th>方法</th><th><code>Thread.sleep()</code></th><th><code>Object.wait()</code></th></tr></thead><tbody><tr><td><strong>类</strong></td><td><code>Thread</code> 类</td><td><code>Object</code> 类</td></tr><tr><td><strong>锁的影响</strong></td><td>不释放锁</td><td>释放锁并进入等待队列</td></tr><tr><td><strong>线程间通信</strong></td><td>不支持线程间通信</td><td>用于线程间通信，通过 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒</td></tr><tr><td><strong>异常</strong></td><td>会抛出 <code>InterruptedException</code></td><td>会抛出 <code>InterruptedException</code></td></tr><tr><td><strong>使用场景</strong></td><td>使线程暂停执行一段时间，通常用于延迟</td><td>用于线程间同步和协作，线程进入等待直到被唤醒</td></tr></tbody></table><h1 id="区别并发和并行"><a href="#区别并发和并行" class="headerlink" title="区别并发和并行"></a><strong>区别并发和并行</strong></h1><p><strong>并发 Concurrent</strong>：两个及以上线程在同一<strong>时间段</strong>执行 （注意是同一时间段，并不是同一时刻）</p><p><strong>并行 Parallel</strong>：两个及以上线程在同一<strong>时刻</strong>执行 （只有在多核 CPU 中才存在并行的概念）</p><p>我们常说的多线程，其实是指在一台机器上并发、串行地执行任务。</p><h1 id="多线程执行可能带来的问题"><a href="#多线程执行可能带来的问题" class="headerlink" title="多线程执行可能带来的问题"></a><strong>多线程执行可能带来的问题</strong></h1><h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p>线程不安全指的是多个线程并发访问共享数据时，程序没有采取适当的同步措施，导致某些数据在访问过程中被破坏，产生不一致的结果。</p><p>（补充：<strong>线程安全</strong> 指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的 <strong>正确性</strong> 和 <strong>一致性</strong>。）</p><h2 id="内存泄漏（和内存溢出要区分开）"><a href="#内存泄漏（和内存溢出要区分开）" class="headerlink" title="内存泄漏（和内存溢出要区分开）"></a>内存泄漏（和内存溢出要区分开）</h2><p>内存泄漏是指程序在运行过程中动态分配了内存，但没有正确释放这些内存，导致内存无法回收，占用更多系统资源，使系统性能下降甚至崩溃。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或多个线程在执行过程中，由于 <strong>每个线程都在等待某个资源被释放</strong>，导致程序进入无法继续执行的状态。</p><p><strong>死锁产生的四个必要条件</strong> ：互斥操作、不可剥夺、循环等待、请求和保持</p><p><strong>预防死锁</strong>：</p><ul><li>破坏请求与保持：一次性申请所有资源</li><li>破坏不可剥夺：当一个占有资源的线程申请其他资源不成功时，令其主动释放其拥有的资源</li><li>破坏循环等待：按一定顺序申请资源</li></ul><p><strong>避免死锁</strong>：事先评估（银行家算法 安全路径）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 equals() 和 hashCode()</title>
    <link href="/2025/03/12/%E6%B5%85%E8%B0%88%20equals()%20%E5%92%8C%20hashCode()/"/>
    <url>/2025/03/12/%E6%B5%85%E8%B0%88%20equals()%20%E5%92%8C%20hashCode()/</url>
    
    <content type="html"><![CDATA[<h1 id="equals-和"><a href="#equals-和" class="headerlink" title="equals() 和 =="></a><code>equals()</code> 和 <code>==</code></h1><p><strong><code>==</code></strong> 可以用来判断基本数据类型和引用数据类型：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><p><code>equals()</code>  只能用来判断两个对象是否相等。 <code>equals()</code> 方法存在于 <code>Object</code> 类中，所以所有类都有 <code>equals()</code> 方法。</p><p><code>Object</code> 类中 <code>equals()</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>     <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过 <code>==</code> 比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h1 id="hashCode-方法的作用"><a href="#hashCode-方法的作用" class="headerlink" title="hashCode() 方法的作用"></a><code>hashCode()</code> 方法的作用</h1><p><code>hashCode()</code> 方法的作用是获取哈希码（或者叫散列码）。这个哈希码的作用是当该对象被存储到哈希表中，确定其在哈希表中的索引位置。<code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code>  函数，并且 <code>hashCode()</code> 是本地方法（也就是用 C 或 C++ 实现的）。</p><h1 id="hashCode-存在的意义"><a href="#hashCode-存在的意义" class="headerlink" title="hashCode() 存在的意义"></a><code>hashCode()</code> 存在的意义</h1><p>原文链接：<a href="https://javaguide.cn/java/basis/java-basic-questions-02.html">https://javaguide.cn/java/basis/java-basic-questions-02.html</a></p><blockquote><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p></blockquote><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p><p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><h1 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a><strong>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？</strong></h1><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>思考</strong>：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。解答可以参考：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答 - 如果天空不死 - 博客园</a></p><p><strong>总结</strong>：</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java代理模式</title>
    <link href="/2025/03/12/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/03/12/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>代理模式属于一种设计模式，简单来说就是我们实现一个代理对象，使其代替对真实对象的访问，这样就能够在不修改原对象的基础上来提供额外操作。代理对象的主要作用就是扩展目标对象的功能，比如在目标方法的执行前后添加一些自定义的操作。代理模式有 <strong>静态代理</strong> 和 <strong>动态代理</strong> 两种实现方式。</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>静态代理的几个特点：</p><ul><li>一对一。每个目标类都要单独写一个代理类。</li><li>纯手动。对每个方法的增强都是手动完成的，一旦接口中添加了新的方法，目标对象和代理对象都要修改。</li></ul><p>静态代理的实现步骤：</p><ul><li>定义一个接口及其实现类（即被代理的类，我们可以称为目标类）。</li><li>创建一个代理类，代理类同样要实现这个接口。</li><li>将目标类注入代理类（确切来说应该是将目标类的实例对象注入），然后在代理类的对应方法中调用目标类的对应方法，在调用前后添加我们想要的操作。</li></ul><p>代码展示：</p><ol><li><p>定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现接口SmsService</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmsService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SmsService smsService;<br><br><span class="hljs-comment">// 注入目标类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SmsProxy</span><span class="hljs-params">(SmsService smsService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.smsService = smsService;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method send()&quot;</span>);<br>        smsService.send(message);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method send()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SmsService</span> <span class="hljs-variable">smsService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsServiceImpl</span>();<br>        <span class="hljs-type">SmsProxy</span> <span class="hljs-variable">smsProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsProxy</span>(smsService);<br>        smsProxy.send(<span class="hljs-string">&quot;java&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>Java中实现动态代理的方法有很多种，比如 <strong>JDK动态代理</strong> 和 <strong>CGLIB动态代理</strong> 。</p><h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><p>在Java动态代理机制当中，核心为 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类。同时 <code>Proxy</code> 类中的 <code>newProxyInstance()</code> 方法为使用频率最高的方法，这个方法主要用来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span><br><span class="hljs-params">                                      Class&lt;?&gt;[] interfaces,</span><br><span class="hljs-params">                                      InvocationHandler h)</span><br>    <span class="hljs-keyword">throws</span> IllegalArgumentException<br>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法有三个参数：</p><ul><li><code>loader</code> ： <strong>被代理的类</strong> 的 类加载器</li><li><code>interfaces</code> ：被代理类实现的接口集合</li><li><code>h</code> ：实现了 <code>InvocationHandler</code> 接口的对象（ <code>h</code> 实际上是一个多态引用）</li></ul><p>当动态代理对象调用一个方法时，这个方法调用会被<strong>转发到 <code>h</code> 的 <code>invoke</code> 方法</strong>来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span><br>        <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>invoke()</code> 方法有三个参数：</p><ul><li><code>proxy</code> ：动态生成的代理类</li><li><code>method</code> ：被代理对象所实现的接口中的方法，也就是用户通过代理对象调用的那个方法</li><li><code>args</code> ： <code>method</code> 方法的参数</li></ul><p>也就是说：</p><p><strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象，</strong></p><p><strong>在调用方法的时候，</strong></p><p>**实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。**你可以在 <code>invoke()</code>方法中自定义处理逻辑，</p><p>比如在方法执行前后做什么事情。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul><li>定义一个接口及其实现类；</li><li>自定义实现 <code>InvocationHandler</code> 接口的类，并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并在调用前后添加一些操作。</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象（可以使用工厂类包装）</li></ul><h2 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h2><p>JDK动态代理有一个问题：只能代理实现了接口的类。为了解决这个问题，我们就可以使用CGLIB动态代理。</p><p>CGLIB 通过继承的方式实现代理。例如在 Spring 的 AOP 模块当中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p>CGLIB 动态代理的核心是 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callback</span>&#123;<br>    <span class="hljs-comment">// 拦截被代理类中的方法</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MethodInterceptor</code> 接口中的 <code>intercept</code> 方法包含四个参数：</p><ul><li><strong>obj</strong> : 被代理的对象（需要增强的对象）</li><li><strong>method</strong> : 被拦截的方法（被代理类中需要增强的方法）</li><li><strong>args</strong> :<code>args</code> 是调用代理对象方法时传入的参数数组。这些是你在调用代理方法时提供的实际参数。</li><li><strong>proxy</strong> : <code>proxy</code> 是 CGLIB 提供的 <code>MethodProxy</code> 对象，它代表了目标方法的代理方法。通过 <code>MethodProxy</code>，你可以调用目标对象的实际方法。</li></ul><p>使用步骤：</p><ul><li><p>定义一个类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliSmsService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义MethodInterceptor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o           被代理的对象（需要增强的对象）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method      被拦截的方法（需要增强的方法）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args        方法入参</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodProxy 用于调用原始方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugMethodInterceptor</span>());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AliSmsService</span> <span class="hljs-variable">aliSmsService</span> <span class="hljs-operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);<br>aliSmsService.send(<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="JDK-动态代理-和-CGLIB-动态代理-的对比"><a href="#JDK-动态代理-和-CGLIB-动态代理-的对比" class="headerlink" title="JDK 动态代理 和 CGLIB 动态代理 的对比"></a>JDK 动态代理 和 CGLIB 动态代理 的对比</h2><ul><li><strong>限制：JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>效率：大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显</li></ul><h1 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h1><p>动态代理更加灵活。</p><p>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>向上转型与向下转型</title>
    <link href="/2025/03/12/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E4%B8%8E%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
    <url>/2025/03/12/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E4%B8%8E%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>向上转型与向下转型是 Java 中关于父子对象转换的两个概念。</p><p>假如我们有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animals</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Eat...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类 继承 父类 Animals</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animals</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;eat bone...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;dog bark...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animals</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;eat fish...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cat sleep...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>向上转型：<code>Animals a = new Cat()</code></li><li>向下转型：<code>Cat cat = (Cat) a</code></li><li>注意：只有向上转型的变量才能向下转型。此时实例 a 就拥有子类自己定义的特有方法 <code>cat.sleep()</code></li></ul><h1 id="为什么要向上转型"><a href="#为什么要向上转型" class="headerlink" title="为什么要向上转型"></a>为什么要向上转型</h1><p>假设我们有一个宠物店类，其中有一个统计宠物数量的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalsShop</span> &#123;<br>    <span class="hljs-comment">// 注意这里用的是Animals泛型，加入宠物时，不必关心宠物的具体类型</span><br>    <span class="hljs-keyword">private</span> List&lt;Animals&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animals&gt;();<br>    <span class="hljs-comment">// 当加入一个宠物时，相当于进行了向上转型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Animals a)</span>&#123;<br>        list.add(a);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> list.size();<br>    &#125;<br>    <span class="hljs-comment">// 取出的宠物也是经过向上转型的，此时类型为Animals</span><br>    <span class="hljs-keyword">public</span> Animals <span class="hljs-title function_">getAnimal</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span>&#123;<br>        <span class="hljs-keyword">return</span> list.get(position);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此可以发现，使用向上转型的方式能够提高代码的灵活性和可扩展性。比如在上述代码中，我们不必关心宠物的具体类型，便可以直接传入 AnimalsShop 类中进行数量统计。</p><h1 id="为什么要向下转型"><a href="#为什么要向下转型" class="headerlink" title="为什么要向下转型"></a>为什么要向下转型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 电子产品接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Electronics</span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">// ThinkPad电脑 实现了电子产品接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thinkpad</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Electronics</span>&#123;<br><br>    <span class="hljs-comment">//Thinkpad引导方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">boot</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;welcome,I am Thinkpad&quot;</span>);        <br>    &#125;<br><br>    <span class="hljs-comment">//使用Thinkpad编程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">program</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;using Thinkpad program&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 鼠标 实现了电子产品接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Electronics</span>&#123;<br><br>    <span class="hljs-comment">//鼠标移动</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;move the mouse&quot;</span>);       <br>    &#125;<br><br>    <span class="hljs-comment">//鼠标点击  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;a click of the mouse&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 购物车 用来装电子产品</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopCar</span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Electronics&gt; mlist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Electronics&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Electronics electronics)</span>&#123;<br>        mlist.add(electronics);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> mlist.size();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Electronics <span class="hljs-title function_">getListItem</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span>&#123;<br>        <span class="hljs-keyword">return</span> mlist.get(position);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THINKPAD</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOUSE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><br>        <span class="hljs-comment">//添加进购物车</span><br>        <span class="hljs-type">ShopCar</span> <span class="hljs-variable">shopcar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShopCar</span>();<br>        shopcar.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thinkpad</span>());<br>        shopcar.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Mouse</span>());<br>        shopcar.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Keyboard</span>());<br><br>        <span class="hljs-comment">//获取大小</span><br>        System.out.println(<span class="hljs-string">&quot;购物车存放的电子产品数量为 ——&gt; &quot;</span>+shopcar.getSize());<br><br>        <span class="hljs-comment">//开始测试thinkpad电脑</span><br>        <span class="hljs-type">Thinkpad</span> <span class="hljs-variable">thinkpad</span> <span class="hljs-operator">=</span> (Thinkpad)shopcar.getListItem(THINKPAD);<br>        thinkpad.boot();<br>        thinkpad.program();<br><br>        System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);<br><br>        <span class="hljs-comment">//开始测试Mouse鼠标</span><br>        <span class="hljs-type">Mouse</span> <span class="hljs-variable">mouse</span> <span class="hljs-operator">=</span> (Mouse)shopcar.getListItem(MOUSE);<br>        mouse.move();<br>        mouse.onClick();<br><br>        System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>很多时候，我们需要把很多种类的实例对象，全部扔到一个集合。比如把Thinkpad笔记本，Mouse鼠标等实例对象，全部扔到一个 Shopcar 购物车集合，但是不可能给每个种类都用一个独立的集合去存放。这个时候我们应该寻找到一个标准来统一这些实例，接口就是一个标准。上面提到的笔记本电脑、鼠标都是电子产品，我们将其抽象为一个 Electronic 接口。</p><p>同时，我们把很多种类的实例对象，全部扔到存放其父类对象的集合。经过了这个过程，子类实例已经赋值给了父类引用（即完成了向上转型）但在这个过程中，子类丢失了其特有的方法，如果我们想要重新找回这些丢失的方法，就要用到向下转型，就像下面这段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开始测试thinkpad电脑</span><br><span class="hljs-type">Thinkpad</span> <span class="hljs-variable">thinkpad</span> <span class="hljs-operator">=</span> (Thinkpad)shopcar.getListItem(THINKPAD);<br>thinkpad.boot();<br>thinkpad.program();<br></code></pre></td></tr></table></figure><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/xyh269/article/details/52231944">https://blog.csdn.net/xyh269/article/details/52231944</a></li><li><a href="https://blog.csdn.net/weixin_44122191/article/details/117133287">https://blog.csdn.net/weixin_44122191/article/details/117133287</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OOP：封装、继承、多态</title>
    <link href="/2025/03/12/OOP%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/"/>
    <url>/2025/03/12/OOP%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="OOP：封装、继承、多态"><a href="#OOP：封装、继承、多态" class="headerlink" title="OOP：封装、继承、多态"></a>OOP：封装、继承、多态</h1><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>封装就是把一个对象的状态信息隐藏在对象内部，不允许外部对象直接访问；但是可以对外提供一些方法来操作属性。其他对象只能通过已经授权的操作来和封装的对象进行操作，而无需了解其内部的实现细节。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>不同类型的对象之间经常会有一些共同点，同时每一个对象中又定义了额外的特性使他们与众不同，我们通过继承就可以使得复用之前的代码非常容易。通过继承，我们可以直接使用父类的属性和方法，又可以实现自己独特的属性和方法，大大减少了代码量，也让代码结构更加清晰。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态主要体现在三个方面：</p><ul><li>子类继承父类</li><li>子类重写父类的方法</li><li>父类引用指向子类的对象</li></ul><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
